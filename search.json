[
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html",
    "href": "posts/function-overloading-in-mojo-pt1/index.html",
    "title": "Function Overloading in Mojo",
    "section": "",
    "text": "Mojo allows multiple functions with the same name to coexist, provided their argument or parameter signatures are different.  Function overloading features are seen in other languages as well, such as C++.\n\nFunction overloading allows semantically similar functions to share a name, facilitates easier customization of implementations based on argument or parameter signatures, and empowers the compiler to more rigorously type check at the function call site.\n\nThis article covers Mojo syntax for function overloading. In future articles we may dive into details of overload resolution at function call site and discuss best practices for overloading.\nTo begin, let’s examine overloading via argument signatures.\n\n\n\n\n\n\nA note on code examples\n\n\n\nThe code examples in this article provide function signatures and invocations, and they typically skip implementation details. This is to maintain a focus on function overloading without distracting particulars of data structures and algorithms."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#call-resolution",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#call-resolution",
    "title": "Function Overloading in Mojo",
    "section": "Call resolution",
    "text": "Call resolution\nThe Mojo compiler resolves the call at invocation site, selecting one of the overloads based on the argument list. Let’s examine the output of executing the insert call in this code:\n\nvar tasks: StringList = StringList()\nlet task1: String = String(\"Review proposed design\")\n\n1# Call Site A\ntasks.insert(task1)\n\n\n1\n\nCall Site A\n\n\n\n\nIn Overload 1\n\n\nThe output shows that Overload 1 was invoked.\nAt Call Site A, insert is invoked with two values. The first is the implicit value tasks of type StringList and the second is the explicit value task1 of type String. Based on the number of values, both Overload 1 and Overload 2 are candidates. Among these two, only Overload 1 matches the argument types. Consequently, the compiler resolved the call at Call Site A to Overload 1.\n\nLet’s take a look at another example:\n\n1 # Call Site B\ntasks.insert(task1, 0)\n\n\n1\n\nCall Site B\n\n\n\n\nIn Overload 2\n\n\nAt Call Site B insert is invoked with three values, of types StringList, String, and IntLiteral. This matches Overload 2. Note that the compiler implicitly converts the literal 0 from type IntLiteral to Int. We’ll discuss type conversions for call resolution in greater depth later in a later article."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#no-overloading-on-result-type",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#no-overloading-on-result-type",
    "title": "Function Overloading in Mojo",
    "section": "No overloading on result type",
    "text": "No overloading on result type\nMojo functions cannot be overloaded on result type alone. Let’s look at what happens when this struct declaration is compiled:\n\nstruct StringList:\n1    # Overload 1\n    # Count all items\n    fn count(self) -&gt; UInt32: ...\n2    # Overload 2\n    # Count all items\n    fn count(self) -&gt; UInt64: ...\n\n\n1\n\nOverload 1\n\n2\n\nOverload 2\n\n\n\n\nerror: Expression [24]:8:5: redefinition of function 'count' cannot overload on return type only\n    fn count(self) -&gt; UInt64: ...   # &lt;2&gt;\n    ^\n\nExpression [24]:5:5: previous definition here\n    fn count(self) -&gt; UInt32: ...   # &lt;1&gt;\n    ^\n\nexpression failed to parse (no further compiler diagnostics)\n\n\nThe compiler generated an error. The accompanying message indicates that Overload 2 of count is not legal since Overload 1 already exists."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#overloaded-constructors",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#overloaded-constructors",
    "title": "Function Overloading in Mojo",
    "section": "Overloaded constructors",
    "text": "Overloaded constructors\nMojo allows constructors to be overloaded as well. For example:\n\nstruct StringList:\n1    # Overload 1\n    # Create empty list\n    fn __init__(inout self):\n        print(\"In Overload 1\")\n2    # Overload 2\n    # Create list initialized with `count` number of copies of `element`\n    fn __init__(inout self, element: String, count: Int):\n        print(\"In Overload 2\")\n3    # Overload 3\n    # Create list initialized with strings from `elements` between `start_index` and    \n    # `end_index`\n    fn __init__(inout self, elements: StringList, start_index: Int, end_index: Int):\n        print(\"In Overload 3\")\n\n\n1\n\nOverload 1\n\n2\n\nOverload 2\n\n3\n\nOverload 3\n\n\n\n\nThe argument lists of the three overloads differ by count or types, in keeping with Mojo’s overloading rules.\nHere are invocations of each of them:\n\n1# Call Site A\nlet names = StringList()\n2# Call Site B\nlet statuses = StringList(\"Pending\", 3)\n3# Call Site C\nlet copied_statuses = StringList(statuses, 1, 3)\n\n\n1\n\nCall Site A\n\n2\n\nCall Site B\n\n3\n\nCall Site C\n\n\n\n\nIn Overload 1\nIn Overload 2\nIn Overload 3\n\n\nAs we can see, the compiler resolves Call Site A, Call Site B, and Call Site C respectively to Overload 1, Overload 2, and Overload 3."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#parameterized-functions",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#parameterized-functions",
    "title": "Function Overloading in Mojo",
    "section": "Parameterized functions",
    "text": "Parameterized functions\nWhen invoked with different types, a parameterized function effectively generates overloads with a shared function name.\nConsider the simple parameterized swap function below that exchanges the referenced values:\n\n# Swap the values of `value1` and `value2`\nfn swap[valueType: Copyable](inout value1: valueType, inout value2: valueType):\n    let temp = value1\n    \n    value1 = value2\n    value2 = temp\n\nThe compiler instantiates a function based on the type of arguments. Here’s an example with Int values:\n\nvar i1 = 2\nvar i2 = 3\n\nprint(\"Before swap:\", i1, i2)\n1# Call Site A\nswap(i1, i2)\nprint(\"After swap:\", i1, i2)\n\n\n1\n\nCall Site A\n\n\n\n\nBefore swap: 2 3\nAfter swap: 3 2\n\n\n\nAnd now we use the same parameterized function with String:\n\nvar s1 = \"Mojo\"\nvar s2 = \"Programming\"\n\nprint(\"Before swap:\", s1, s2)\n1# Call Site B\nswap(s1, s2)\nprint(\"After swap:\", s1, s2)\n\n\n1\n\nCall Site B\n\n\n\n\nBefore swap: Mojo Programming\nAfter swap: Programming Mojo\n\n\n\n\n\n\n\n\n\nExplicit parameter specification\n\n\n\nNote that in swap invocations at Call Site A and Call Site B we relied on the compiler to determine the valueType parameter. An alternative is to spell out the parameter as shown below:\n\nvar i1 = 2\nvar i2 = 3\n\nprint(\"Before swap:\", i1, i2)\nswap[Int](i1, i2)\nprint(\"After swap:\", i1, i2)\n\n\nvar s1 = \"Mojo\"\nvar s2 = \"Programming\"\n\nprint(\"Before swap:\", s1, s2)\nswap[StringLiteral](s1, s2)\nprint(\"After swap:\", s1, s2)\n\nBefore swap: 2 3\nAfter swap: 3 2\nBefore swap: Mojo Programming\nAfter swap: Programming Mojo"
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#call-resolution-1",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#call-resolution-1",
    "title": "Function Overloading in Mojo",
    "section": "Call resolution",
    "text": "Call resolution\nIf the replacement_field value parameter is not used, the Mojo compiler attempts to resolve the call to Overload 1. Let’s examine the output of executing calls to format.\nOur first application of format generates a labelled username:\n\n1# Call Site A\nlet username = StringUtils.format(\"Username: {}\", \"dev#1\")\n\n\n1\n\nCall Site A\n\n\n\n\nIn Overload 1\n\n\nThe output shows that Overload 1 was invoked.\nWhile both overloads are candidates, Overload 1 is the simpler match and the one the compiler picked. We’ll dive into the compiler’s resolution rules in greater detail in a future article.\nLet’s examine another example - this time leveraging the second overload, which carries the replacement_field parameter. Consider a case in which the format_str argument has the “{}” substring embedded, however it is to be preserved; not replaced. In this example, we have a JSON object with an name/value pair where the value is the empty JSON object “{}” and needs to be preserved. So, we instead use “$$” as the replacement field:\n\n1# Call Site B\nlet empty_object = StringUtils.format[\"$$\"]('{\"$$\": {}}', \"postal_address\")\n\n\n1\n\nCall Site B\n\n\n\n\nIn Overload 2\n\n\nThe output shows that Overload 2 was invoked.\nWhile both overloads are candidates, Overload 2 is the only one that accepts a StringLiteral value parameter and the one the compiler picked.\n\n\n\n\n\n\n\nExplicit parameter specification\n\n\n\nNote that Call Site B did not explicitly pass in String as a parameter and the Mojo compiler successfully inferred the type automatically. In contrast, here is invocation with two explicit parameters:\n\nlet empty_object = StringUtils.format[\"$$\", String]('{\"$$\": {}}', \"postal_address\")\n\nIn Overload 2"
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#call-resolution-2",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#call-resolution-2",
    "title": "Function Overloading in Mojo",
    "section": "Call resolution",
    "text": "Call resolution\nLet’s take a look at the output of executing some calls to format. The following generates a JSON object with one name/value pair:\n\n1# Call Site C\nlet key_value = StringUtils.format(\"format {} {}\", \"usage_count\", 6)\n\n\n1\n\nCall Site C\n\n\n\n\nIn Overload 3\n\n\nThe output indicates that Overload 3 was invoked.\nCall Site C invokes format with no ‘StringLiteral’ value parameter and three arguments. So the compiler selects Overload 3 was invoked.\nAs another example, we format a log entry with a standard format for date/time, log level, and log text.\n\n1# Call Site D\nlet log_entry = StringUtils.format(\n    \"[{}] {}: {}\", \n    \"2024-01-11T19:20:52Z\", \n    3, \n    \"File write completed.\"\n)\n\n\n1\n\nCall Site D\n\n\n\n\nIn Overload 5\n\n\nThe output demonstrates that Overload 5 was invoked.\nCall Site D invokes format without replacement_field value parameter and four arguments. Since Overload 5 is the only candidate without a StringLiteral value parameter and 4 arguments, it is the only one examined further by the compiler. The first argument is a String and the remaining of Stringable types as required by that overload. Consequently, the compiler fully resolved the call to Overload 5."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#mojo",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#mojo",
    "title": "Function Overloading in Mojo",
    "section": "Mojo",
    "text": "Mojo\n\nOfficial page for the Mojo programming language.\nOfficial documentation on function overloading on arguments in Mojo.\nOfficial documentation on function overloading on parameters in Mojo."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#function-overloading-in-c",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#function-overloading-in-c",
    "title": "Function Overloading in Mojo",
    "section": "Function overloading in C++",
    "text": "Function overloading in C++\nNote that in C++ the words argument and parameter have different and overlapping meanings when compared to their meanings in Mojo. In C++, variables defined in function declaration and used within function definition are called parameters, while values used for function invocation are called arguments.\n\nOverview of function overloading in C++ and coverage of overload resolution in C++.\n\nTemplate functions in C++ are the closest feature to parameterized functions in Mojo.\n\nOverview of function templates in C++ and brief coverage of function template resolution in C++."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#function-overloading-in-python",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#function-overloading-in-python",
    "title": "Function Overloading in Mojo",
    "section": "Function overloading in Python",
    "text": "Function overloading in Python\nPython does not natively feature overloaded functions and compile-time call resolution. However, approximations are available.\n\nDispatch on type of first argument via functools.singledispatch.\nDispatch on types of multiple arguments via multimethod or multipledispatch."
  },
  {
    "objectID": "posts/function-overloading-in-mojo-pt1/index.html#string-formatting-functions",
    "href": "posts/function-overloading-in-mojo-pt1/index.html#string-formatting-functions",
    "title": "Function Overloading in Mojo",
    "section": "String formatting functions",
    "text": "String formatting functions\nThese functions are available in many programming languages.\n\nString formatting in Python.\nString formatting in C++."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "about",
    "section": "",
    "text": "Kaizen Engineering is dedicated to continuously refining software engineering practices to reliably and efficiently deliver results of impeccable quality.\n\n\n\n\n\n\n\nShaival Varma\nAlan Horne\n\n\nShaival pursues best practices in engineering, team organization and project management, and the powerful synergies among them.\nAlan has a keen interest in software correctness and optimization, functional programming, mathematics, and game development.\n\n\n\n \n    \n  \n    \n     contact"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "blog",
    "section": "",
    "text": "Function Overloading in Mojo\n\n\n\n\n\n\n\nfunctions\n\n\nmethods\n\n\noverloading\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2024\n\n\nKaizen Engineering\n\n\n\n\n\n\nNo matching items"
  }
]